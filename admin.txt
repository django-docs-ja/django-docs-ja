.. _The Django admin site:

====================
Django admin サイト
====================

:revision-up-to: 8012 (1.0pre SVN)

Django の最も強力な機能の一つに、自動生成される admin インタフェースがあり
ます。 admin はモデルのメタデータを読み込んで、強力で実運用に耐えるインタ
フェースを生成し、コンテンツの製作者がすぐにサイトにコンテンツを投入できる
ようにします。このドキュメントでは、 Django の admin インタフェースを有効に
したり、カスタマイズしたりする方法を解説します。

.. admonition:: 注意

    admin サイトは Django 0.96 から大幅にリファクタされました。このドキュメ
    ントでは、よりカスタマイズ機能の充実した新しい admin サイトについて解説
    しています。この admin サイトの仕様は、 Django の開発をよく追いかけてい
    る人なら、一度は "newforms-admin" という名前で耳にしたことがあるはずで
    す。

.. _Overview:

概要
========

Django admin サイトは、以下の 5 つのステップを通して有効化します:

    1. ``django.contrib.admin`` を ``INSTALLED_APPS`` に追加します。

    2. admin インタフェースでの編集を可能にするモデルを決めます。

    3. 2 で決めたモデルに対して、必要なら ``ModelAdmin`` クラスを定義します。
       ``ModelAdmin`` はモデルごとにカスタマイズした admin の機能やオプショ
       ンをカプセル化しています。

    4. ``AdminSite`` をインスタンス化して、モデルや ``ModelAdmin`` クラスを
       指定します。

    5. ``AdminSite`` インスタンスを URLconf にフックします。

.. _`ModelAdmin objects`:

``ModelAdmin`` オブジェクト
============================

``ModelAdmin`` クラスは、 admin インタフェース上のモデルを表現しています。
このクラスは、アプリケーションの ``admin.py`` という名前のファイルに保存し
ます。 ``ModelAdmin`` の簡単な例を以下に示します::

    from django.contrib import admin
    from myproject.myapp.models import Author
    
    class AuthorAdmin(admin.ModelAdmin):
        pass
    admin.site.register(Author, AuthorAdmin)

.. _`ModelAdmin Options`:

``ModelAdmin`` のオプション
---------------------------------

``ModelAdmin`` はとてもフレキシブルなクラスです。このクラスには、 admin イ
ンタフェースをカスタマイズするためのオプションがいくつもあります。オプショ
ンは、全て、 ``ModelAdmin`` のサブクラスで以下のように指定します::

    class AuthorAdmin(admin.ModelAdmin):
        date_hierarchy = 'pub_date'

``date_hierarchy``
~~~~~~~~~~~~~~~~~~

``date_hierarchy`` をモデルの ``DateField`` や ``DateTimeField`` に指定する
と、変更リストのページに、指定フィールドの日付を使って日付ベースで絞り込み
できるナビゲーションが組み込まれます。

例::

    date_hierarchy = 'pub_date'

``fieldsets``
~~~~~~~~~~~~~

admin の「追加 (add)」および「変更 (change)」ページのレイアウトを制御するに
は、 ``fieldsets`` を使います。

``fieldsets`` は 2 要素のタプルのリストです。各タプルは admin フォームペー
ジ上の ``<fieldset>`` を表します (``<fieldset>`` はいわばフォームの「セクショ
ン」です)。

フィールドセットは ``(name, field_options)`` の形式をとります。 ``name``
はフィールドセットの名前を表す文字列で、 ``field_options`` はフィールドセッ
ト内で表示したいフィールドの情報を入れた辞書です。この情報の中に、表示した
いフィールドのリストも指定します。

``django.contrib.flatpages.FlatPage`` モデルから抜き出した例を示します::
    
    class FlatPageAdmin(admin.ModelAdmin):
        fieldsets = (
            (None, {
                'fields': ('url', 'title', 'content', 'sites')
            }),
            ('Advanced options', {
                'classes': ('collapse',),
                'fields': ('enable_comments', 'registration_required', 'template_name')
            }),
        )

このフィールドセットによって、 admin のページは以下のようになります:

    .. image:: http://media.djangoproject.com/img/doc/flatfiles_admin.png

``fieldsets`` を指定しない場合、 Django は ``AutoField`` でなく、かつ
``editable=True`` であるようなフィールドを、モデルに定義した順番に個別のフィー
ルドセットとして表示します。

``field_options`` 辞書には以下のようなキーを指定できます:

``fields``
    フィールドセット内に表示するフィールド名からなるタプルです。必須のキー
    です。
    
    使い方::
        
        {
        'fields': ('first_name', 'last_name', 'address', 'city', 'state'),
        }

    同じ行に複数のフィールドを表示したい場合、それらのフィールドをタプルで
    ラップして入れます。下の例では、 ``first_name`` と ``last_name`` が同じ
    行に表示されます::
        
        {
        'fields': (('first_name', 'last_name'), 'address', 'city', 'state'),
        }

``classes``
    フィールドセットに適用される追加の CSS クラス名です。
    
    使い方::
        
        {
        'classes': ['wide', 'extrapretty'],
        }

    admin サイトのデフォルトのスタイルシートで定義されている便利なクラスと
    して ``collapse`` と ``wide`` があります。 ``collapse`` スタイルのフィー
    ルドセットは、 admin ページでは最初折り畳まれ (collapse) ており、小さな
    "クリックして展開 (click to expand)" リンクに置き換わっています。
    ``wide`` スタイルのフィールドセットには水平方向に追加のスペースが加わり
    ます。

``description``
    各フィールドセットの先頭に表示する追加の文字列で、オプションです。この
    文字列はそのまま表示されるので、 HTML を使えますし、 HTML で特別扱いさ
    れる文字 (アンパーサンドなど) は自分でエスケープしておかねばなりません。

``filter_horizontal``
~~~~~~~~~~~~~~~~~~~~~

ユーザビリティが紙一重の ``<select multiple>`` の代わりに、気の利いた控えめ
な Javascript の「フィルタ」インタフェースを使います。フィルタインタフェー
スを横並びにして表示させたいフィールドのリストを指定してください。フィルタ
インタフェースを縦並びにしたい場合は ``filter_vertical`` を使ってください。

``filter_vertical``
~~~~~~~~~~~~~~~~~~~

``filter_horizontal`` とほぼ同じですが、フィルタインタフェースを縦並びで表
示します。

``list_display``
~~~~~~~~~~~~~~~~

admin の変更リストページに表示するフィールドを制御するには ``list_display``
を使います。

使い方::

    list_display = ('first_name', 'last_name')

``list_display`` を指定しなければ、 admin サイトは各オブジェクトの
``__unicode__()`` 表現を表示するカラムを一つだけ表示します。

``list_display`` にはいくつか特殊なケースがあります:

    * フィールドが ``ForeignKey`` の場合、関連づけられているオブジェクトの
      ``__unicode__()`` を表示します。

    * ``ManyToManyField`` フィールドの表示は、テーブルの各行に対して個別に
      SQL 文を実行することになってしまうのでサポートしていません。どうして
      も表示させたいなら、カスタムメソッドをモデルに実装して、メソッドの名
      前を ``list_display`` に追加してください (``list_display`` へのカスタ
      ムメソッドの追加については、後で詳しく説明しています)。

    * フィールドが ``BooleanField`` や ``NullBooleanField`` の場合、
      ``True`` や ``False`` の代りに "オン" や "オフ" を示すアイコンを表示
      します。

    * モデルのメソッド名を指定した場合、 Django はそのメソッドを呼び出して、
      戻り値を表示します。このメソッドには、フィールドのヘッダに使うための
      ``short_description`` という関数属性がなければなりません。

      例を示します::

          class Person(models.Model):
              name = models.CharField(max_length=50)
              birthday = models.DateField()

              def decade_born_in(self):
                  return self.birthday.strftime('%Y')[:3] + "0's"
              decade_born_in.short_description = 'Birth decade'
          
          class PersonAdmin(admin.ModelAdmin):
              list_display = ('name', 'decade_born_in')

    * モデルのメソッド名を指定した場合、 Django はデフォルトでメソッドの出
      力を HTML エスケープします。メソッドの出力をエスケープしたくない場合
      には、メソッドの ``allow_tags`` 属性の値を ``True`` にしてください。

      以下に例を示します::

          class Person(models.Model):
              first_name = models.CharField(max_length=50)
              last_name = models.CharField(max_length=50)
              color_code = models.CharField(max_length=6)

              def colored_name(self):
                  return '<span style="color: #%s;">%s %s</span>' % (self.color_code, self.first_name, self.last_name)
              colored_name.allow_tags = True
          
          class PersonAdmin(admin.ModelAdmin):
              list_display = ('first_name', 'last_name', 'colored_name')

    * モデルのメソッド名を指定していて、メソッドが ``True`` か ``False`` を
      返す場合、メソッドの ``boolean`` 属性を ``True`` に設定しておくと、
      Django は「オン」や「オフ」のアイコンを表示します。
      
      以下に例を示します::

          class Person(models.Model):
              first_name = models.CharField(max_length=50)
              birthday = models.DateField()

              def born_in_fifties(self):
                  return self.birthday.strftime('%Y')[:3] == 5
              born_in_fifties.boolean = True
          
          class PersonAdmin(admin.ModelAdmin):
              list_display = ('name', 'born_in_fifties')


    * ``__str__()`` および ``__unicode__()`` メソッドは他のモデルメソッドと
      同じように ``list_display`` に入れられるので、以下のように書いても全
      く問題ありません::

          list_display = ('__unicode__', 'some_other_field')

    * 通常、 ``list_display`` の要素のうち、実際のデータベースのフィールド
      に対応していないものは、変更リストページで並び順を変えるときのカラム
      には使えません。 Django はソートをすべてデータベースレベルで行うから
      です。
      
      ただし、 ``list_display`` のいずれかの要素が実際にデータベース上のあ
      るフィールドを指している場合、 ``admin_order_field`` という属性を使っ
      て、 Django にそのことを教えられます。

      例を示しましょう::

        class Person(models.Model):
            first_name = models.CharField(max_length=50)
            color_code = models.CharField(max_length=6)

            def colored_first_name(self):
                return '<span style="color: #%s;">%s</span>' % (self.color_code, self.first_name)
            colored_first_name.allow_tags = True
            colored_first_name.admin_order_field = 'first_name'
        
        class PersonAdmin(admin.ModelAdmin):
            list_display = ('first_name', 'colored_first_name')

      この例では、 Django は Admin 上で ``colored_first_name`` を並べ変える
      際に ``first_name`` フィールドを使います。

``list_display_links``
~~~~~~~~~~~~~~~~~~~~~~

``list_display_links`` を設定すると、 ``list_display`` のどのフィールドを
オブジェクトの「変更」ページにリンクするかを制御できます。

デフォルトでは、変更リストページはオブジェクトの変更ページ中の第一カラム、
すなわち ``list_display`` の先頭に指定したフィールドにリンクを張ります。
``list_display_links`` を使うと、リンク先のカラムを変更できます。
``list_display_links`` には、フィールド名のリストまたはタプルを
(``list_display`` と同じ形式で) 指定します。

``list_display_links`` に指定するフィールド名は、一つでも複数でも構いません。
フィールド名が ``list_display`` に列挙されている限り、 Django はどんなに多
くの (あるいはどんなにわずかな) フィールドがリンクされていても問題にしませ
ん。必要なのは、 ``list_display_links`` を使うには ``list_display`` を定義
しておかねばならない、ということだけです。

以下の例では、 ``first_name`` および ``last_name`` フィールドが変更リス
トページにリンクされます::

    class PersonAdmin(admin.ModelAdmin):
        list_display = ('first_name', 'last_name', 'birthday')
        list_display_links = ('first_name', 'last_name')

最後に、 ``list_display_links`` を使うには ``list_display`` も指定せねばな
らないので注意しましょう。


``list_filter``
~~~~~~~~~~~~~~~

admin の変更リストページの右側のサイドバーにあるフィルタを有効にするには、
``list_filter`` を設定します。この値はフィールド名のリストにします。
各フィールド名は ``BooleanField``, ``CharField``, ``DateField``,
``DateTimeField``, ``IntegerField``, ``ForeignKey`` のいずれかでなければ
なりません。

以下の例は ``django.contrib.auth.models.User`` モデルからとったもので、
``list_display`` と ``list_filter`` の仕組みを示しています:: 

    class Admin:
        list_display = ('username', 'email', 'first_name', 'last_name', 
                        'is_staff')
        list_filter = ('is_staff', 'is_superuser')

上のコードによって、 admin の変更リストは以下のようになります:

    .. image:: http://media.djangoproject.com/img/doc/users_changelist.png

(この例では、後述の ``search_fields`` も定義しています。)

``list_per_page``
~~~~~~~~~~~~~~~~~

admin 変更リストをページ分割 (paginate) で表示するときに、各ページに何個の
アイテムを表示するかを決めます。デフォルト値は ``100`` です。

``list_select_related``
~~~~~~~~~~~~~~~~~~~~~~~

``list_select_related`` を設定すると、 admin の変更リストページに表示するオ
ブジェクトリストを取得する際に ``select_related()`` を使うよう Django に指
示できます。これにより、データベースクエリの発行数を抑えられます。

値は ``True`` または ``False`` にします。デフォルトは ``False`` です。

``list_display`` のいずれかのフィールドが ``ForeignKey`` の場合、 Django は
この設定に関わらず ``select_related()`` を使います。

``select_related()`` の詳細は `select_related() のドキュメント`_ を参照
してください。

.. _the select_related() docs: ../db-api/#select-related
.. _`select_related() のドキュメント`: `the select_related() docs`_

``inlines``
~~~~~~~~~~~

後述の ``InlineModelAdmin`` を参照してください。

``ordering``
~~~~~~~~~~~~

``ordering`` を設定すると、 admin の変更リストにおける整列順を指定できます。
値はタプルからなるリストで、モデルの ``ordering`` パラメタと同じ形式で指定
します。

この値を指定しない場合、 Django はモデルのデフォルトの整列順を使います。

``prepopulated_fields``
~~~~~~~~~~~~~~~~~~~~~~~

フィールドの値を別のフィールドの値からセットさせたい場合は、以下のように、
``prepopulated_fields`` にフィールド名を対応付けた辞書を設定してください::

    class ArticleAdmin(admin.ModelAdmin):
        prepopulated_fields = {"slug": ("title",)}

この属性で設定されたフィールドは、 JavaScript を使って指定フィールドから値
を取り込みます。

``DateTimeField``, ``ForeignKey`` および ``ManyToManyField`` は
``prepopulated_fields`` に指定できません。

``radio_fields``
~~~~~~~~~~~~~~~~

デフォルトでは、Django の admin は ``ForeignKey`` のフィールドや
``choices`` の設定されたフィールドに対してセレクタボックス (<select>) イン
タフェースを使います。 ``radio_fields`` にフィールド名を指定しておくと、
Django はセレクタボックスの代りにラジオボタンのインタフェースを使います。
例えば、 ``group`` が ``Person`` モデル上の  ``ForeignKey`` フィールド
であれば、以下のように書けます::

    class PersonAdmin(admin.ModelAdmin):
        radio_fields = {"group": admin.VERTICAL}

ラジオボタンの並び方を指定するシンボル、 ``HORIZONTAL`` または ``VERTICAL``
は ``django.contrib.admin`` モジュールにあります。

この属性に指定できるのは、 ``ForeignKey`` フィールドと ``choices`` が設定さ
れているフィールドだけです。

``raw_id_fields``
~~~~~~~~~~~~~~~~~

デフォルトでは、Django の admin サイトは ``ForeignKey`` フィールドに対して
セレクタボックス (<select>) インタフェースを使います。しかし、時にはリレー
ション先の全てのオブジェクトの入ったセレクタボックスが生成され、ドロップダ
ウン表示されるのを避けたい場合もあります。

``raw_id_fields`` に、 ``ForeignKey`` フィールドを指定すると、そのフィール
ドは主キーを入力するための ``Input`` ウィジェットに変更されます。

``save_as``
~~~~~~~~~~~

``save_as`` を指定すると、オブジェクト編集ページで「別名で保存 (save as)」
機能を使えるようになります。

通常、オブジェクト編集ページには三つの保存オプション、すなわち「保存
(Save)」、「保存して編集を続ける (Save and continue editing)」、「保存して
もう一つ追加 (Save and add another)」があります。 ``save_as`` を ``True``
にすると。「保存してもう一つ追加」は「別名で保存 (Save as)」に置き換わりま
す。

「別名で保存」は、現在のオブジェクトをそのまま保存するのではなく、(新たな
ID を持った) 別のオブジェクトとして保存することです。

デフォルトでは、 ``save_as`` は ``False`` に設定されています。

``save_on_top``
~~~~~~~~~~~~~~~

``save_on_top`` を指定すると、 admin の変更フォームの最上部に保存ボタンを追
加できます。

通常、保存ボタンはフォームの最下部だけに表示されます。 ``save_on_top`` を指
定すると、ボタンは最下部だけでなく最上部にも表示されます。

デフォルトでは、 ``save_on_top`` は ``False`` です。

``search_fields``
~~~~~~~~~~~~~~~~~

``search_fields`` を指定すると、 admin の変更リストページで検索ボックスを使
えるようになります。この値は、ユーザが検索クエリをテキストボックスに入力し
たときに検索の対象に含めるフィールド名のリストです。

フィールドは ``CharField`` や ``TextField`` のような何らかのテキストフィー
ルドでなければなりません。 DB API の「リレーションを追跡する」表記を使えば、
``ForeignKey`` を介したフィールドの指定も行えます::

    search_fields = ['foreign_key__related_fieldname']

admin の検索ボックスで検索を実行すると、 Django は検索クエリを単語に分解し
て、各単語を含むような全てのオブジェクトを返します。検索は大小文字を区別せ
ず、 ``search_fields`` に指定したフィールドのうち少なくとも一つに単語が入っ
ていればヒットします。例えば、 ``search_fields`` が
``['first_name', 'last_name']`` に設定されている場合、ユーザが 
``john lennon`` を検索すると、 Django は以下のような ``WHERE`` 節を持った
SQL と等価な検索を実行します::

    WHERE (first_name ILIKE '%john%' OR last_name ILIKE '%john%')
    AND (first_name ILIKE '%lennon%' OR last_name ILIKE '%lennon%')

より高速な、あるいはより制約の厳しい検索を行うには、フィールド名の前に以下
のような演算子を置きます:

``^``
    フィールドの先頭にマッチします。例えば、 ``search_fields`` を
    ``['^first_name', '^last_name']`` にして、ユーザが ``john lennon`` を検
    索した場合、Django は以下のような ``WHERE`` 節の SQL に等価な検索を実行
    します::

        WHERE (first_name ILIKE 'john%' OR last_name ILIKE 'john%')
        AND (first_name ILIKE 'lennon%' OR last_name ILIKE 'lennon%')

    このクエリを使うと、データベースはカラムの先頭部分だけをチェックすれば
    よく、カラム中のデータ全体を調べなくてもよくなるため、通常の
    ``'%john%'`` クエリよりも効率的に検索を実行できます。加えて、カラムにイ
    ンデクスが設定されていれば、データベースによっては  ``LIKE`` クエリであっ
    てもインデクスを使ったクエリを実行できるという利点があります。

``=``
    大小文字を区別しない厳密一致です。例えば、 ``search_fields`` を
    ``['=first_name', '=last_name']`` にして、ユーザが ``john lennon`` を検
    索した場合、 Django は以下のような ``WHERE`` 節の SQL に等価な検索を実行
    します::

        WHERE (first_name ILIKE 'john' OR last_name ILIKE 'john')
        AND (first_name ILIKE 'lennon' OR last_name ILIKE 'lennon')
    
    クエリ入力はスペース区切りなので、この例に従うと、 ``first_name`` が
    ``'john winston'`` である (スペースを含む) ようなレコードは検索でき
    ないので注意してください。

``@``
    全文検索マッチを実行します。デフォルトの search メソッドに似ていますが、
    インデクスを使います。現在のところ MySQL でしか使えません。

.. _`ModelAdmin media definitions`:

``ModelAdmin`` のメディア定義
--------------------------------

たまに、 CSS や JavaScript を追加・変更ビューに追加したい場合があります。
``ModelAdmin`` に内部クラス ``Media`` を定義すれば、これを実現できます::

    class ArticleAdmin(admin.ModelAdmin):
        class Media:
            css = {
                "all": ("my_styles.css",)
            }
            js = ("my_code.js",)

これらのメディア名のパスには ``MEDIA_URL`` の内容が前置されます。また、
`forms の通常のメディア定義`_ と同じ規則が当てはまります。

.. _regular media definitions on forms: ../forms/#media
.. _`forms の通常のメディア定義`: `regular media definitions on forms`_

.. _`InlineModelAdmin objects`:

``InlineModelAdmin`` オブジェクト
====================================

admin インタフェースには、他のモデルクラスのインスタンスを同じページで編集
する機能があります。この機能をインライン編集と呼びます。インラインモデルを
指定するには、 ``ModelAdmin.inlines`` 属性を使います::

    class BookInline(admin.TabularInline):
        model = Book
    
    class AuthorAdmin(admin.ModelAdmin):
        inlines = [
            BookInline,
        ]

Django は、 ``InlineModelAdmin`` のサブクラスとして、以下の二つを提供してい
ます::

    * ``TabularInline``
    * ``StackedInline``

これら二つの違いは、単にレンダリングに使われるテンプレートに過ぎません。

.. _`InlineModelAdmin options`:

``InlineModelAdmin`` のオプション
-----------------------------------

``InlineModelAdmin`` クラスは ``ModelAdmin`` のサブクラスなので、以下に挙げ
る独自の機能の他に、 ``ModelAdmin`` の機能を全て継承しています:

``model``
~~~~~~~~~

インライン編集する対象のモデルです。必須の引数です。

``fk_name``
~~~~~~~~~~~

モデルの外部キーの名前です。たいていの場合、外部キーは自動的に決定できます
が、親モデルに対して外部キーを複数張っているようなモデルの場合は、
``fk_name`` を明示的に決める必要があります。

``formset``
~~~~~~~~~~~

デフォルト値は ``BaseInlineFormset`` です。独自のフォームセットを指定すれば、
色々とカスタマイズできます。インラインオブジェクトのフォームは
`モデルフォームセット`_ で生成されています。

.. _model formsets: ../modelforms/#model-formsets
.. _`モデルフォームセット`: `model formsets`_

``form``
~~~~~~~~

``form`` の値は ``ModelAdmin`` から継承されます。この値は、インラインオブジェ
クトのフォームセットを生成するときに ``fomrset_factory`` に渡されます。

``extra``
~~~~~~~~~

フォームセットが、初期のフォームに加えて表示する追加のフォーム数を制御しま
す。詳しくは `formsets のドキュメント`_ を参照してください。

.. _formsets documentation: ../forms/#formsets
.. _`formsets のドキュメント`: `formsets documentation`_

``max_num``
~~~~~~~~~~~

インラインで表示するフォームの最大個数を制御します。この値は直接オブジェク
トの数には関係しませんが、あまり小さな値が設定されていると、影響することも
あります。詳しくは `formsets での max_num の扱い`_ を参照してください。

.. _max_num in formsets: ../modelforms/#limiting-the-number-of-objects-editable
.. _`formsets での max_num の扱い`: `max_num in formsets`_

``template``
~~~~~~~~~~~~

インラインオブジェクトをレンダリングするときに使われるテンプレートです。

``verbose_name``
~~~~~~~~~~~~~~~~

モデルの内部クラス ``Meta`` の ``verbose_name`` の設定をオーバライドします。

``verbose_name_plural``
~~~~~~~~~~~~~~~~~~~~~~~

モデルの内部クラス ``Meta`` の ``verbose_name_plural`` の設定をオーバライド
します。

.. _Working with a model with two or more foreign keys to the same parent model:

一つのモデルから複数の外部キーが張られている場合のインライン編集の扱い
---------------------------------------------------------------------------

一つのモデルに対して、複数の外部キーが張られている場合があります。以下のよ
うなモデルを例に考えてみましょう::

    class Friendship(models.Model):
        to_person = models.ForeignKey(Person, related_name="friends")
        from_person = models.ForeignKey(Person, related_name="from_friends")

``Person`` の admin サイトで、インラインの追加・編集ページを表示したくても、
どの外部キーを辿らせるかは自動で決められません。従って、明示的に決めてやる
必要があります::

    class FriendshipInline(admin.TabularInline):
        model = Friendship
        fk_name = "to_person"
    
    class PersonAdmin(admin.ModelAdmin):
        inlines = [
            FriendshipInline,
        ]

.. _`AdminSite objects`:

``AdminSite`` オブジェクト
===========================

.. _`Hooking AdminSite instances into your URLconf`:

URLconf に ``AdminSite`` インスタンスをフックする
---------------------------------------------------

Django admin サイト構築の最後のステップは、 ``AdminSite`` インスタンスの
URLconf への設置です。設置を行うには、 URL を ``AdminSite`` インスタンスの
``root`` メソッドに振り向けます。

以下の例では、デフォルトの ``AdminSite`` インスタンスである
``django.contrib.admin.site`` を、 ``/admin/`` という URL にマップしていま
す::

    # urls.py
    from django.conf.urls.defaults import *
    from django.contrib import admin
    
    admin.autodiscover()

    urlpatterns = patterns('',
        ('^admin/(.*)', admin.site.root),
    )

この例では、 ``admin.autodiscover()`` を使って、 ``INSTALLED_APPS`` の
``admin.py`` モジュールを自動的にロードしています。

次の例では、 ``AdminSite`` インスタンス ``myproject.admin.admin_site`` 
を ``/myadmin/`` という URL にマップしています::

    # urls.py
    from django.conf.urls.defaults import *
    from myproject.admin import admin_site

    urlpatterns = patterns('',
        ('^myadmin/(.*)', admin_site.root),
    )

このように、 ``AdminSite`` インスタンスを自作している場合は、
``myproject.admin`` モジュールの中で各アプリケーションの admin.py モジュー
ルを import しているはずなので、 ``autodiscover`` を呼ぶ必要はありません。

URLパターンの正規表現には、 admin サイトのルート URL の後ろ全ての URL 部分
を含むようなグループ表記を *必ず* 入れておかねばなりません。この例では
``(.*)`` を使っています。

.. _Multiple admin sites in the same URLconf:

一つの URLconf で複数の admin サイトを使う
-------------------------------------------

Django で作られた一つの Web サイト上で、複数の admin サイトインスタンスを簡
単に運営できます。方法は、単に ``AdminSite`` インスタンスを複数にして別々の
URL で設置するだけです。

下の例では、  ``/basic-admin/`` と ``/advanced-admin/`` という二つの URL で、
``myproject.admin.basic_site`` と ``myproject.admin.advanced_site`` という
``AdminSite`` インスタンスを使って、別々のバージョンの admin サイトを運営し
ています::

    # urls.py
    from django.conf.urls.defaults import *
    from myproject.admin import basic_site, advanced_site

    urlpatterns = patterns('',
        ('^basic-admin/(.*)', basic_site.root),
        ('^advanced-admin/(.*)', advanced_site.root),
    )
