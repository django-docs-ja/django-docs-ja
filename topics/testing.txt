.. _topics-testing:

==============================
Djangoアプリケーションのテスト
==============================

:revision-up-to: 8961 (1.0)

.. module:: django.test
   :synopsis: Django アプリケーション用のテストツールです。

今日の Web 開発者にとって、自動化されたテストはバグ潰しの工程で極めて有用な
ツールです。複数のテストを集めた **テストスイート** を使えば、Web開発におけ
るいくつもの問題を解決したり回避したりできます:

  * 新たなコードを書く際、コードが期待通りに動作するかテストできます。

  * 以前のコードを修正したりリファクタする場合、テストによって、コードの変
    更がアプリケーションに意図しない影響を及ぼさないか調べられます。

Web アプリケーションは、 HTTP レベルのリクエスト処理、フォームの検証と処理、
そしてテンプレートレンダリングまで、複数のロジックレイヤから構成されていま
す。そのため、Webアプリケーションのテストは複雑なタスクです。 Django のテス
ト実行フレームワークと関連ユーティリティを使えば、仮想的なリクエストを発行
したり、テストデータを挿入したり、アプリケーションの出力を調べて、コードが
期待通りに動作しているか検証したりできます。

しかも素晴らしいことに、テストはとても簡単なのです。

このドキュメントは前後半の 2 つの節に別れています。前半では Django における
テストの書き方を、後半ではテストの実行方法を説明します。

.. _Writing tests:

テストを書く
============

Django でテストを書く方法は主に 2 つあり、それぞれ Python の標準ライブラリ
についてくる二つのテストフレームワークに対応しています。フレームワークは以
下の 2 つです:

    * **doctest** -- 関数やクラスの docstring (ドキュメンテーション文字列)
      に埋め込まれたテストで、例えば以下のように Python の対話インタプリタ
      セッションを模した方法で書かれています::

          def my_func(a_list, idx):
              """
              >>> a = ['larry', 'curly', 'moe']
              >>> my_func(a, 0)
              'larry'
              >>> my_func(a, 1)
              'curly'
              """
              return a_list[idx]

    * **ユニットテスト (unit test)** -- 以下の例のように、テストを
      ``unittest.TestCase``` のサブクラスのメソッドとして表現したものです::

          import unittest

          class MyFuncTestCase(unittest.TestCase):
              def testBasic(self):
                  a = ['larry', 'curly', 'moe']
                  self.assertEquals(my_func(a, 0), 'larry')
                  self.assertEquals(my_func(a, 1), 'curly')

好みに応じて、どちらのテストを使ってもかまいませんし、両方のテストを組み合
わせてもかまいません。また、後でほんの少しだけ説明しますが、他のテストフレー
ムワークを使っても構いません。

.. _Writing doctests:

doctest を書く
--------------

doctest は、Python の標準モジュール、 doctest_ によるテストです。 doctest
は docstring (ドキュメンテーション文字列) から、 Python の対話インタプリタ
セッションの形式をとる部分を探し出して実行します。 doctest の詳しい構造につ
いての解説はこのドキュメントの範囲を超えた話なので、公式ドキュメントを参照
してください。

.. admonition:: **docstring** とは?

    docstring の詳しい説明 (と、効果的な docstring の書き方) は、
    :pep:`257` (訳注: PEP 257 の和訳は 
    http://www.python.jp/doc/contrib/peps/pep-0257.txt にあります) に書かれ
    ています:
        
        docstring とは、モジュールや関数、クラス、メソッド定義のブロック中
        の先頭に置かれた文字列リテラルです。 docstring を定義すると、オブジェ
        クトの ``__doc__`` という特殊な属性になります。
        

    例えば、下の関数には、関数の説明の入った docstring があります::

        def add_two(num):
            "引数に指定した数に 2 を加えて返します。"
            return num + 2

    テストはそれ自体素晴らしいドキュメントになることも多いので、テストをそ
    のまま docstring に入れておけば、ドキュメント化とコードのテストの 
    *両方を* 効率的に行えます。

テストランナは、 Django アプリケーションの中の以下のファイルから doctest を
探して実行します:

    * ``models.py`` ファイル。モジュールレベル、かつ/またはモデルレベルの
      doctest を記述します。一般には、アプリケーションレベルの doctest はモ
      ジュールの docstring として記述し、モデルレベルの docstring はモデル
      クラスの docstring として記述します。

    * アプリケーションディレクトリ、すなわち ``models.py`` の入ったディレク
      トリ下に置かれた ``tests.py`` という名前のファイル。このファイルは、
      モデルに関係しないような doctest を書きたい場合のフックとして使えます。

doctest の文字列は ``models.py`` の全てのオブジェクトに対して記述できますが、
慣習的には、アプリケーションレベルの doctest はモジュールの docstring に、
モデルレベルの doctest は各モデルの docstring に配置します。

モデル定義で doctest を使った例を示します::

    # models.py

    from django.db import models
    
    class Animal(models.Model):
        """
        鳴き声から動物を調べるテスト
        
        # 動物インスタンスを生成する
        >>> lion = Animal.objects.create(name="lion", sound="roar")
        >>> cat = Animal.objects.create(name="cat", sound="meow")
        
        # speak() を呼び出す
        >>> lion.speak()
        'The lion says "roar"'
        >>> cat.speak()
        'The cat says "meow"'
        """
        
        name = models.CharField(max_length=20)
        sound = models.CharField(max_length=20)
        
        def speak(self):
            return 'The %s says "%s"' % (self.name, self.sound)


:ref:`テストを実行する <running-tests>` と、テストユーティリティは上の
docstring を探し出して、Python の対話セッションに見える部分を検出し、そこに
書かれた命令を実行して、docstring に書かれた結果と実際の実行結果が一致する
かどうかを確かめます。

モデルテストの場合、テストランナが独自にテストデータベースを作成します。す
なわち、データベースに対してアクセスするテスト -- 例えば、モデルインスタン
スを生成して保存するようなテスト -- が、実運用のためのデータベースに影響を
及ぼすことはありません。 doctest はいずれも「白紙状態」、すなわち、各モデル
のデータベーステーブルが空の状態で実行されます (詳しくは、後述のフィクスチャ
の節を参照してください) 。この機能を使うには、 Django がデータベースに接続
するときのユーザに ``CREATE DATABASE`` の権限を持たせておかねばならないので
注意してください。

doctest の詳しい動作原理は、 `標準ドキュメントの doctest の項`_
を参照してください。

.. doctest: http://python.jp/doc/release/lib/module-doctest.html
.. _doctest: http://python.jp/doc/release/lib/module-doctest.html
.. _standard library documentation for doctest: doctest_
.. _`標準ドキュメントの doctest の項`: doctest_

.. _Writing unit tests:

ユニットテストを書く
--------------------

Django の単体テストもまた、doctest と同様、標準ライブラリモジュールの
unittest_ を使います。このモジュールは、 doctest_ とは違った、 クラスベース
のやり方でテストを定義します。

doctest と同様、 Django のテストランナは、以下の二つの場所からユニットテス
トを探します:

    * ``models.py`` ファイル。テストランナはこのモジュールから
      ``unittest.TestCase`` のサブクラスを探します。

    * アプリケーションディレクトリ、すなわち ``models.py`` の入ったディレク
      トリ下に置かれた ``tests.py`` という名前のファイル。上と同様に、テス
      トランナはこのモジュールから ``unittest.TestCase`` のサブクラスを探し
      ます。

以下の ``unittest.TestCase`` のサブクラスは、前節の doctest と同じテストを
実現しています::

    import unittest
    from myapp.models import Animal
    
    class AnimalTestCase(unittest.TestCase):

        def setUp(self):
            self.lion = Animal.objects.create(name="lion", sound="roar")
            self.cat = Animal.objects.create(name="cat", sound="meow")
        
        def testSpeaking(self):
            self.assertEquals(self.lion.speak(), 'The lion says "roar"')
            self.assertEquals(self.cat.speak(), 'The cat says "meow"')
            
:ref:`テストを実行する <running-tests>` と、テストユーティリティはデフォル
トの動作として、 ``models.py`` と ``tests.py`` に入っている全てのテストケー
ス (つまり ``unittest.TestCase`` のサブクラス) を捜し出し、そこからテストス
イートを自動的に構築して、スイートを実行します。

開発バージョンの Django には、あるモジュールのテストスイートを定義する方法
をもう一つ提供しています:  ``models.py`` や ``tests.py`` で ``suite()`` メ
ソッドを定義している場合、 Django のテストランナはこのメソッドを使ってテス
トスイートを構築します。この仕様は、ユニットテストにおいて 
:ref:`おすすめのテストスイート構築方法 <>` に従っています。複雑なテストスイー
トの構築方法についての詳細は Python のドキュメントを参照してください。

``unittest`` の詳細は `標準ライブラリドキュメントの unittest の項`_ を参照
してください。

.. unittest: http://docs.python.org/lib/module-unittest.html
.. _unittest: http://python.jp/doc/release/lib/module-unittest.html
.. _standard library unittest documentation: unittest_
.. suggested organization: http://docs.python.org/lib/organizing-tests.html
.. _suggested organization: http://python.jp/doc/release/lib/organizing-tests.html
.. _`標準ライブラリドキュメントの unittest の項`: unittest_
.. _`おすすめのテストスイート構築方法`: `suggested organization`_

.. _Which should I use?:

どちらのテストを使うべきか
--------------------------

Django は標準的な Python テストフレームワークの両方をサポートしているので、
どちらを選ぶかは、開発者個々人の好み次第です。もちろん、 *両方* を同時に使っ
てもかまいません。

とはいえ、テストを初めて書く開発者にとっては、この選択は混乱
のもとになるでしょう。そこで、どちらのテストを使うべきかを決める手がかりに
なるよう、 doctest と単体テストの主な違いについて示します:

  * そこそこ Python に慣れているなら、 ``doctest`` の方がより「Python的
    (pythonic)」に感じることでしょう。 doctest はテストをできるだけ楽に書け
    るように設計されているので、クラスやメソッドを書くときのオーバヘッドが
    ほとんどありません。単に docstring にテストを書くだけでよいのです。それ
    に、モジュールに対してドキュメントを自動生成させられるという利点もあり
    ます。つまり、 doctest を上手に書けば、ドキュメント作成とテストを同時に
    片付けられて一石二鳥、というわけです。

    また、テストにまだ慣れていない開発者は、 doctest を使った方が早くテスト
    について学べることでしょう。

  * Java での開発経験のある開発者なら、 ``unittest`` フレームワークはとても
    理解しやすいはずです。 ``unittest`` は Java の JUnit に影響を受けている
    ので、他の言語で JUnit から派生したテストフレームワークを使ったことがあ
    るのなら、``unittest`` はかなりしっくりくるはずです。

  * 同じコードを含むような一連のテストを書くときには、 ``unittest`` フレー
    ムワークのクラスとメソッドによる設計が気に入るでしょう。共通のタスクを
    抽象化して、メソッド化できるからです。また、 ``unittest`` フレームワー
    クは ``unittest`` はテストの初期化／終了処理のルーチンをサポートしてい
    るので、テストケースを実行するときの環境を高い水準でコントロールできま
    す。

繰り返しになりますが、(一つのアプリケーションの中であっても) 両方のシステム
を並べて使えることを忘れないでください。どちらのテストシステムにも、状況に
応じて適した部分があるので、大抵のプロジェクトでは、最終的には両方のテスト
システムを使うことになるものです。

.. _running-tests:
.. _Running tests:

テストを実行する
================

テストを実行するには、プロジェクトの ``manage.py`` ユーティリティを使います::

    $ ./manage.py test

特定のアプリケーションに対してテストを実行したければ、コマンドラインにアプ
リケーションの名前を追加します。例えば、 :setting:`INSTALLED_APPS` に
``myproject.polls`` と ``myproject.animals`` というアプリケーションが入って
おり、 animals の単体テストを実行したいだけなら、以下のようにします::
 
    $ ./manage.py test animals

``animals`` ではなく、 ``myproject.animals`` なので注意してください。

.. versionadded:: 1.0
   実行したいテストを選べるようになりました。

単体テストを実行する際、どのテストを実行するかを指定できます。あるアプリケー
ション用のテストケースを実行する場合 (例えば、上で解説した AnimalTestCase
の場合) は、コマンドラインにテストケースの名前を追加してください::

    $ ./manage.py test animals.AnimalTestCase

**開発バージョンの Django で新たに追加された機能:**
テストケース中の個別のテストメソッドを実行したければ、メソッド名を指定して
ください::

    $ ./manage.py test animals.AnimalTestCase.testFluffyAnimals

.. _The test database:

テストデータベース
-------------------
 
データベースを必要とするテスト (モデルのテスト) に、「本番の (実運用環境の)」
データベースは必要ありません。テストの際には、空の別のデータベースが作成さ
れます。

テストがパスするか失敗するかに関わらず、テストデータベースは全てのテストを
実行し終えると消去されます。

デフォルトでは、
.. _Understanding the test output:

テストの出力を理解する
----------------------

テストを実行すると、まずテストランナ自身の初期化メッセージが表示されます::

    Creating test database...
    Creating table myapp_animal
    Creating table myapp_mineral
    Loading 'initial_data' fixtures...
    No fixtures found.

このメッセージは、テストランナがテストデータベースを作成したことを示してい
ます。テストデータベースは、空の、何もない状態から作成したデータベースで、
(モデルテストのような) データベースの必要なテストで使われます。

デフォルトでは、テストデータベースの名前は、 :setting:`DATABASE_NAME` に指
定したデータベース名の前に ``test_`` を付けたものです。 SQLite データベース
エンジンを使っている場合、デフォルトではテストをメモリ上のデータベースで行
います(すなわち、データベースをメモリ上に生成し、ファイルシステムを全く経由
しません！) 。テストデータベースの名前をデフォルト意外の値にしたければ、
:setting:`TEST_DATABASE_NAME` 設定を使って指定します。
 
テスト用に別のデータベースを使うことを除けば、テストランナは設定ファイルの
データベースに関する他の設定、 :setting:`DATABASE_ENGINE`,
:setting:`DATABASE_USER`, :setting:`DATABASE_HOST` などをそのまま使います。
テストデータベースは :setting:`DATABASE_USER` の権限で作成されるので、この
ユーザは新たに生成されたデータベースを操作する権限を備えていなければなりま
せん。

.. versionadded:: 1.0

テスト用データベースの文字セットエンコーディング設定を細かく調整したいのな
ら、 :setting:`TEST_DATABASE_CHARSET` 設定を使ってください。 MySQL を使って
いるなら、 :setting:`TEST_DATABASE_COLLATION` でテストデータベースで使うコ
レーション(collation) を指定できます。これらの設定については、 
:ref:`settings ファイルのドキュメント<ref-settings>` を参照してください。

.. TBD

Other test conditions
---------------------

Regardless of the value of the :setting:`DEBUG` setting in your configuration
file, all Django tests run with :setting:`DEBUG=False`. This is to ensure that
the observed output of your code matches what will be seen in a production
setting.

.. _Understanding the test output:

テストプログラムの出力を理解する
---------------------------------

テストを実行すると、テストランナ自体が大量に出力するメッセージに出くわすで
しょう。コマンドラインの ``verbosity`` オプションを使えば、メッセージの詳細
レベルを制御できます::

    Creating test database...
    Creating table myapp_animal
    Creating table myapp_mineral
    Loading 'initial_data' fixtures...
    No fixtures found.

上のメッセージは、テストランナがデータベースをテストしたことを示します。

テストデータベースが生成されると、 Django はテストを実行します。全てのテス
トにパスすると、最後には以下のようなメッセージが表示されます::

    ----------------------------------------------------------------------
    Ran 22 tests in 0.221s

    OK

一方、失敗したテストがあると、失敗したテストに関する詳しい情報が表示されま
す::

    ======================================================================
    FAIL: Doctest: ellington.core.throttle.models
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/dev/django/test/doctest.py", line 2153, in runTest
        raise self.failureException(self.format_failure(new.getvalue()))
    AssertionError: Failed doctest test for myapp.models
      File "/dev/myapp/models.py", line 0, in models

    ----------------------------------------------------------------------
    File "/dev/myapp/models.py", line 14, in myapp.models
    Failed example:
        throttle.check("actor A", "action one", limit=2, hours=1)
    Expected:
        True
    Got:
        False

    ----------------------------------------------------------------------
    Ran 2 tests in 0.048s

    FAILED (failures=1)

エラー出力の詳細はこのドキュメントの範囲を超えるので解説はしませんが、ほと
んど直感的に理解できる内容のはずです。詳しくは、 Python の ``unittest`` ラ
イブラリのドキュメントを参照してください。

スクリプトのリターンコードは失敗したテストや出力のおかしかったテストの総数で
す。全てのテストにパスしていれば、リターンコードは 0 です。この仕様は、テス
トランナをシェルスクリプト上で動かしたり、テストが成功したかどうかをテスト
ランナのレベルで調べたい場合に便利です。

.. _Testing tools:

テスト用のツール
================

Django は、テストを書くときに便利なツールをいくつか提供しています。

.. _The test client:

テストクライアント
------------------

.. module:: django.test.client
   :synopsis: Django のテストクライアントです。

テストクライアント (test client) は、簡単なダミーブラウザとして動作する
Python のクラスです。テストクライアントを使うと、ビューをテストしたり、
プログラムを使ってDjango で作られたアプリケーションとやりとりできます。

テストクライアントを使ってできることをいくつか挙げましょう:

  * ある URL に対する GET や POST をシミュレートでき、低水準の HTTP (レスポ
    ンスヘッダや状態コード) 情報から、ページの内容まで、リクエストに対するレ
    スポンスの全てを調べられます。

  * 特定の URL に対して正しいビューが呼び出されるかどうかを調べられます。

  * 特定のリクエストに対して、特定のテンプレートを使ったレンダリングが行わ
    れ、その際に特定の値が入ったコンテキストが使われているかどうかを調べら
    れます。

テストクライアントは Twill_ や Selenium_ やその他のブラウザ自動化フレームワー
クを置き換えようとするものではありません。 Django のテストクライアントはもっ
と別の部分に焦点を当てているのです。すなわち:

  * 正しいビューが呼び出され、ビューが正しいコンテキストデータを生成してい
    るかどうかは、 Django のテストクライアントを使って調べてください。

  * Twill や Selenium は、 *レンダリング済みの* HTML や、 JavaScript の機能
    のような Web ページの *ビヘイビア* のテストに使ってください。
   
網羅的なテストスイートでは、両方のタイプのテストを組み合わせて使うはずです。

.. _Twill: http://twill.idyll.org/
.. _Selenium: http://www.openqa.org/selenium/

.. _Overview and a quick example:

テストの概要と簡単な例
~~~~~~~~~~~~~~~~~~~~~~

テストクライアントを使うには、 ``django.test.client.Client`` をインスタンス
化して、 Web ページを取得します::

    >>> from django.test.client import Client
    >>> c = Client()
    >>> response = c.post('/login/', {'username': 'john', 'password': 'smith'})
    >>> response.status_code
    200
    >>> response = c.get('/customer/details/')
    >>> response.content
    '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 ...'

上の例でわかるように、 ``Client`` は Python 対話インタプリタのセッション中
でもインスタンス化できます。

テストクライアントの動作には重要な点がいくつかあります:

    * テストクライアントを実行するために Web サーバを起動する必要は
      *ありません* 。実際、 Web サーバがまったく動いていなくても、テストは
      何の問題もなく実行できるのです。というのも、テストクライアントは HTTP
      通信のオーバヘッドを回避して、 Django フレームワークに直接アクセスし
      ているからです。このからくりによって、ユニットテストを高速に実行でき
      ます。

    * ページを取得するときには、ドメインを含まない *パス部分だけ* を指定す
      るよう気をつけてください。例えば、以下の呼び出し::

          >>> c.get('/login/')

      は正しいですが、次の呼び出し::

          >>> c.get('http://www.example.com/login/')

      は正しくありません。

      Django のプロジェクトから生成されていない Web ページは、テストクライ
      アントで取得できません。Django 以外の Web ページを取得したければ、
      urllib_ や urllib2_ のような Python 標準ライブラリを使ってください。

    * テストクライアントは URL の解決に :setting:`ROOT_URLCONF` に指定され
      た URLconf を使います。

    * 上の例は Python の対話インタプリタ中でも動作しますが、一部のテンプレー
      ト関連の機能などは *テストの実行中だけ* でしか使えません。

      というのも、 Django のテストランナは、あるビューでどのテンプレートが
      ロードされるかを決定するためにちょっとした黒魔術的なコードを使ってい
      るからです。この黒魔術 (実際には、メモリ上のテンプレートシステムに対
      するパッチ) は、テスト実行時にしか適用されません。

.. _urllib: http://docs.python.org/lib/module-urllib.html
.. _urllib2: http://docs.python.org/lib/module-urllib2.html

.. _Making requests:

リクエスト生成
~~~~~~~~~~~~~~

リクエストの生成には、 ``django.test.client.Client`` クラスを使います。
``Client`` は引数なしで生成します。:

.. class:: Client()

    ``Client`` のインスタンスからは、以下のメソッドを呼び出せます:

    .. method:: Client.get(path, data={})

        ``path`` に対する GET リクエストを行い、 ``Response`` オブジェクト
        を返します。 ``Response`` オブジェクトについては後で説明します。


        引数 ``data`` は辞書オブジェクトで、キー／値のペアが GET データのペ
        イロードの生成に使われます。例えば::

            >>> c = Client()
            >>> c.get('/customers/details/', {'name':'fred', 'age':7})

        は、以下のような GET リクエストの送信と同じです::

            /customers/details/?name=fred&age=7

    .. method:: Client.post(path, data={}, content_type=MULTIPART_CONTENT)

        ``path`` に対する POST リクエストを行い、 ``Response`` オブジェクト
        を返します。

        引数 ``data`` は辞書オブジェクトで、キー／値のペアが POST データの
        ペイロード生成に使われます。例えば::

            >>> c = Client()
            >>> c.post('/login/', {'name': 'fred', 'passwd': 'secret'})

        は、以下のパス::

            /login/

        への POST リクエストで、以下の POST データ::

            name=fred&passwd=secret

        を伴います。

        ``content_type`` を指定した場合 (例えば XML ペイロードの場合には
	``text/xml``)、引数 ``data`` の中身は POST リクエストそのままで送信
	され、 ``Content-Type`` ヘッダに ``content_type`` の値を使います。

        ``content_type`` を指定しなければ、 ``data`` の中身は
        ``multipart/form-data`` で送信されます。この場合、 ``data`` の中の
        キー／値のペアは、マルチパートメッセージにエンコードされ、 POST デー
        タのペイロード生成に使われます。

        あるキーに対して複数の値を提出 (submit) する場合 (例えば、
	``<select multiple>`` の選択結果を指定する場合など) は、キーに対す
	る値をリストやタプルにしてください。例えば、``choices`` という名前
	のフィールドから 3 つの行を選択して提出したければ::

            ``{'choices': ('a', 'b', 'd')}``

        のようにします。

        ファイルの送信には特別な扱いが必要です。ファイルの POST を行う場合、
        以下のように、ファイル名フィールドの名前をキーに、アップロードした
        いファイルのファイルハンドルを値に設定します::

            >>> c = Client()
            >>> f = open('wishlist.doc')
            >>> c.post('/customers/wishes/', {'name':'fred', 'attachment':f})
            >>> f.close()

        (``attachment`` という名前には特に意味はありません。ファイルを処理
        するコードで使いたい名前を指定してください)

        送信するファイルのハンドルは、 ``post()`` 後に手動で閉じねばならな
        いので注意してください。

    .. method:: Client.login(**credentials)

        .. versionadded:: 1.0

        Django の :ref:`認証システム <topics-auth>` を使っていて、ログイン
        済みのユーザを扱う必要がある場合、テストクライアントの ``login()``
        メソッドを使えば、サイトへログインするユーザをシミュレートできます。

        このメソッドを呼び出すと、テストクライアントはログインに必要なクッ
        キーとセッションデータを持つようになり、テスト対象のビューのうち、
        ログインの必要なテストをパスできるようになります。

        ``credentials`` 引数の形式は、使っている 
	:ref:`認証バックエンド <authentication-backends>` によって変わりま
	す (認証バックエンドは :setting:`AUTHENTICATION_BACKENDS` で設定し
	ます)。	Django が提供している標準の認証バックエンド
	(``ModelBackend``) を使う場合、 ``credentials`` にはユーザのユーザ
	名とパスワードをキーワー引数で指定します::

            >>> c = Client()
            >>> c.login(username='fred', password='secret')
            # これでログイン保護されたビューに入れるようになりました。


        認証バックエンドを変えた場合、このメソッドは違った認証情報を要求す
        るかもしれません。その場合、 ``login()`` は、認証バックエンドの
        ``authenticate()`` メソッドが必要とする認証情報をそのまま要求します。

        ``login()`` は、指定した認証情報が承認され、ログインに成功した場合に
        ``True`` を返します。

        このメソッドを使うには、事前にユーザを登録しておかねばなりません。上
        で説明したように、テストランナはテストデータベースを使ってテストを実
        行するので、デフォルトではユーザが登録されていません。そのため、運用
        環境で使えるユーザはテスト環境では使えないのです。テストスイートの一
        環として、手動で (Django のモデル API を使って) ユーザを作成するか、
        フィクスチャでユーザを登録してください。

    .. method:: Client.logout()

        Django の :ref:`認証システム <topics-auth>` を使っている場合、
        ``logout()`` メソッドで、サイトからユーザをログアウトさせる効果をシ
        ミュレートできます。

        このメソッドを呼び出すと、テストクライアントはクッキーとセッション
        データを全て消去して、デフォルトの状態に戻します。それ以降のリクエ
        ストは、ビューからは ``AnonymousUser`` から送信されたリクエストとみ
        なされます。

.. _Testing Responses:

レスポンスのテスト
~~~~~~~~~~~~~~~~~~

``get()`` および ``post()`` メソッドは、いずれも ``Response`` オブジェクト
を返します。 ``Response`` オブジェクトは Django のビューが返す
``HttpResponse`` オブジェクトと同じ *ではありません* 。このオブジェクトは
検証用のテストコード作成に便利なデータをいくつか備えています。

``Response`` オブジェクトには以下のようなプロパティがあります:

.. class:: Response()

    .. attribute:: client

        レスポンス要求の生成に使われたテストクライアントです。

    .. attribute:: content

        レスポンスの本体部分 (body) です。ビューがレンダリングによって生成
        した最終的なページコンテンツか、エラーメッセージです。

    .. attribute:: context

        レスポンスのページコンテンツのレンダに使われた ``Context`` オブジェ
        クトです。

        複数のテンプレートを使ってレンダリングを行った場合、 ``context`` は
        ``Context`` オブジェクトをレンダリングで使った順に並べたリストです。
 
    .. attribute:: request

        レスポンスを得るために使用したリクエストデータです。
 
    .. attribute:: status_code

        レスポンスの HTTP 状態コードです。全ての HTTP 状態コードのリストは
        RFC2616_ を参照してください。

    .. attribute:: template

        最終的なページコンテンツのレンダリングに使われた ``Template`` のイ
        ンスタンスです。テンプレートをファイルからロードした場合、テンプレー
        トのファイル名を ``template.name`` で調べられます
        (``'admin/index.html'`` のような形式の文字列です)。

	複数のテンプレートをレンダリングしている場合 (例えば
	:ref:`テンプレートの継承 <template-inheritance>`_ を使っている場合)、
	``template`` はレンダリング順に並んだ  ``Template`` オブジェクトの
	リストです。

また、レスポンスオブジェクトを辞書のように扱っても、HTTPヘッダに設定された
値にアクセスできます。例えば、レスポンスのコンテンツタイプは
``response['Content-Type']`` でアクセスできます。

.. _RFC2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html

.. _Exceptions:

例外
~~~~

テストクライアントのアクセス先のビューが例外を送出するような場合、テストケー
ス内で例外にアクセスできます。例外のテストを行うには、通常の
``try...catch`` ブロックか、 ``unittest.TestCase.assertRaises()`` を使いま
す。

ただし、 ``Http404`` や ``PermissionDenied``, ``SystemExit`` といった例外は
テストケースからアクセスできません。 Django はこれらの例外を内部的に捕捉し
て、対応する適切な HTTP 応答コードに変換してしまうからです。これらの例外に
対しては、 ``response.status_code`` のチェックで対応してください。

.. _Persistent state:

セッションの永続性
~~~~~~~~~~~~~~~~~~

テストクライアントの動作はステートフルです。あるレスポンスにクッキーが入っ
ていると、クッキーはテストクライアント中に保存され、それ以降の ``get()`` や
``post()`` リクエストで使われます。

テストクライアントは、クッキーの有効期限ポリシを守りません。クッキーを期限
切れにしたければ、該当クッキーを ``client.cookies`` から手動で削除するか、
新たな ``Client`` インスタンスを生成してください (全てのクッキーを除去しま
す)。

テストクライアントには、永続セッション情報 (persistent state information)
を保存するためのプロパティが二つあります。これらのプロパティは、必要に応じ
てテスト条件の一部として検査できます。

.. attribute:: Client.cookies

    Python の ``SimpleCookie`` 型のオブジェクトで、全てのクライアントクッキー
    の現在値が入っています。詳しくは `Cookie モジュールのドキュメント`_ を
    参照してください。

.. attribute:: Client.session

    セッション情報の入った辞書ライクなオブジェクトです。詳しくは 
    :ref:`セッションのドキュメント <topics-http-sessions>` を参照してくださ
    い。

.. _Cookie module documentation: http://docs.python.org/lib/module-Cookie.html
.. _`Cookie モジュールのドキュメント`: `Cookie module documentation`_

.. _Example:
             
ユニットテストの例
~~~~~~~~~~~~~~~~~~

テストクライアントを使った簡単なユニットテストを以下に示します::

    import unittest
    from django.test.client import Client

    class SimpleTest(unittest.TestCase):
        def setUp(self):
            # unittest を使う場合、毎回 Client を生成する必要があります。
            self.client = Client()

        def test_details(self):
            # GET リクエストを発行します。
            response = self.client.get('/customer/details/')

            # レスポンスが 200 OK であるか調べます。
            self.failUnlessEqual(response.status_code, 200)

            # レンダリングされるコンテキストの customers の長さが 5 である
            # か確かます。
            self.failUnlessEqual(len(response.context['customers']), 5)


.. _TestCase:

TestCaseクラス
--------------

.. currentmodule:: django.test

Django は拡張用に以下のベースクラスを提供しています:

.. class:: TestCase()

を提供しています。このクラスは、Web サイトのテスト時に便利な機能をいくつか
追加しています。

通常のユニットテストを ``unittest.TestCase`` から Django 独自の 
``TestCase`` に移行するのは簡単で、単にベースクラスを ``unittest.TestCase``
から ``django.test.TestCase`` に変更するだけです。 ``django.test.TestCase``
は、標準の Python ユニットテスト機能はそのままに、さらに便利な機能を提供し
ています。

.. _Default Test Client:

デフォルトのテストクライアント
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

.. attribute:: TestCase.client

``django.test.TestCase`` クラスのインスタンス内に入っているテストケースは全
て、デフォルトの `テストクライアント`_ にアクセスできます。このテストクライ
アントは ``self.client`` で参照できます。テストクライアントはテストごとに再
生成されるので、テスト間でクッキーのような状態情報が継承される心配はありま
せん。

例えば、以下のコード::

    import unittest
    from django.test.client import Client

    class SimpleTest(unittest.TestCase):
        def test_details(self):
            client = Client()
            response = client.get('/customer/details/')
            self.failUnlessEqual(response.status_code, 200)

        def test_index(self):
            client = Client()
            response = client.get('/customer/index/')
            self.failUnlessEqual(response.status_code, 200)

では、各テストで ``Client`` をインスタンス化していますが、実際は次のコード
のように、 ``self.client`` を参照するだけでよいのです::

    from django.test import TestCase

    class SimpleTest(TestCase):
        def test_details(self):
            response = self.client.get('/customer/details/')
            self.failUnlessEqual(response.status_code, 200)

        def test_index(self):
            response = self.client.get('/customer/index/')
            self.failUnlessEqual(response.status_code, 200)

.. _topics-testing-fixtures:
.. _Fixture loading:

フィクスチャの読み込み
~~~~~~~~~~~~~~~~~~~~~~

.. attribute:: TestCase.fixtures

データベースがバックにあるウェブサイトのテストで、データベース上に何もデー
タが入っていなければあまり意味はありません。データベースにテストデータを入
れやすくするために、 Django の独自 ``TestCase`` クラスは 
**フィクスチャ (fixture)** の読み込み機能を提供しています。

フィクスチャとは、一群のデータを Django がデータベースに取り込める形式にし
たものです。例えば、ユーザアカウントを持つようなサイトを作っている場合、テ
スト中は仮のユーザアカウントの入ったフィクスチャを作り、データベースに入れ
ておくと便利です。

最も素直なフィクスチャの作成方法は、 ``manage.py dumpdata`` コマンドを使う
というものです。 ``dumpdata`` を使うにはデータベースに既に何らかのデータが
入っていなければなりません。詳しくは :ref:`dumpdata のドキュメント <dumpdata>`
を参照してください。

.. note::
    ``manage.py syncdb`` を実行したことがあるなら、あなたの知らないうちにフィ
    クスチャは使われています。最初に ``syncdb`` を実行したときに、 Django
    は ``initial_data`` という名前のフィクスチャをインストールします。この
    メカニズムを使えば、 (カテゴリのデフォルトセットのような) 新たなデータ
    セットをデータベースに組み込めます。 

    ``initial_data`` 以外の名前のフィクスチャは、 
    ``django-admin.py loaddata`` で手動で組み込めます。
    
単体テストでフィクスチャを使う場合、フィクスチャを作成して Django のプロジェ
クトディレクトリ下に置き、 ``dhango.test.TestCase`` のサブクラスの
``fixtures`` クラス属性を指定します::

    from django.test import TestCase
    from myapp.models import Animal

    class AnimalTestCase(TestCase):
        fixtures = ['mammals.json', 'birds']

        def setUp(self):
            # 従来通りのテスト定義

        def testFluffyAnimals(self):
            # フィクスチャを使うテスト


ユニットテストは、以下のように動作します:

  * テストケースの開始時で、かつ ``setUp()`` の実行前に、 Django はデータベー
    スを一掃して、データベースを ``syncdb`` 直後の状態に戻します。

  * 次に、テストケースクラスに指定した全てのフィクスチャをインストールしま
    す。上の例では、 ``mammals`` という名前の JSON フィクスチャと、
    ``birds`` という名前のフィクスチャがインストールされます。フィクスチャ
    の定義とインストールに関する詳細は :ref:`loaddata のドキュメント <loaddata>`
    を参照してください。

このフラッシュ／ロードの作業はテストケースの実行毎に繰り返されるので、テス
トの結果が他のテストや以前に実行したテストの影響を受けたり、テストの順番に
左右されることはありません。

.. _URLconf configuration:

URLconf の設定
~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

.. attribute:: TestCase.urls

アプリケーションでビューを定義している場合、テストクライアントを使ってビュー
を検査するテストを組み込みたいことがあるでしょう。しかし、エンドユーザはア
プリケーションのビューを自分の好きな URL でデプロイできるので、テストを行う
際には、ビューが特定の URL でアクセスできると期待してはなりません。

テスト用の URL 空間を指定するために、 ``django.test.TestCase`` はテストスイー
ト実行中に使われる URLconf をカスタマイズできる仕組みを提供しています。
``TestCase`` インスタンスに ``urls`` 属性を指定しておくと、 ``TestCase``
はその値をテスト実行中だけ ``ROOT_URLCONF`` に使います。

使い方を示しましょう::

    from django.test import TestCase
    
    class TestMyViews(TestCase):
        urls = 'myapp.test_urls'

        def testIndexPageView(self):
            #  ``Client`` を使ってビューをテストする

このテストケースは、ケースの実行中だけ、 ``myapp.test_urls`` を URLconf と
して使います。

.. _emptying-test-outbox:
.. _Emptying the test outbox:

メール送信箱の内容抹消
~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

Django 独自の ``TestCase`` クラスを使うと、テストランナは各テストケースの開
始時にメールの送信箱に入っている内容を消去します。

テスト中のメールサービスの詳細は `メールサービス`_ を参照してください。

.. _Assertions:

アサーション
~~~~~~~~~~~~

.. versionadded:: 1.0

通常の Python ``unittest.TestCase`` クラスが備えている ``assertTrue`` や
``assertEquals`` のようなアサーションメソッドと同様、 Django 独自の
``TestCase`` クラスでも Web アプリケーションをテストする上で便利な様々な
独自のアサーションメソッドを提供しています。

.. method:: TestCase.assertContains(response, text, count=None, status_code=200)

    ``status_code`` に指定した状態コードで ``Response`` インスタンスが生成
    され、レスポンスのコンテンツ内に ``text`` が入っているかどうか調べるア
    サーションです。 ``count`` を指定すると、 ``text`` は正確に ``count``
    回出現せねばなりません。

.. method:: TestCase.assertNotContains(response, text, status_code=200)

    ``status_code`` に指定した状態コードで ``Response`` インスタンスが生成
    され、レスポンスのコンテンツ内に ``text`` が入っていないことを確認する
    アサーションです。

.. method:: assertFormError(response, form, field, errors)

    ``form`` に指定したフォーム上のフィールド ``field`` で、 ``errors`` に
    指定したエラーリストと同じエラーが送出されるかどうか調べるアサーション
    です。

    ``form`` はテンプレートコンテキスト上の ``Form`` インスタンスの名前です。

    ``field`` はフォーム内のフィールドの名前です。 ``field`` の値が
    ``None`` であれば、非フィールドエラー (特定のフィールドに関連付けられて
    いない、 ``form.non_field_errors()`` でアクセスできるエラー) がチェック
    されます。

    ``errors`` はエラー文字列か、エラー文字列のリストです。フォームの検証結
    果として返されるのと同じ形式です。

.. method:: assertRedirects(response, expected_url, status_code=302, target_status_code=200)

    レスポンスが ``status_code`` に指定したリダイレクト状態コードを持ち、か
    つ ``expected_url`` へのリダイレクトを指示しており、さらにリダイレクト
    先の内容を HTTP 状態コード ``target_status_code`` で取得できるかどうか
    調べるアサーションです。

.. method:: assertTemplateUsed(response, template_name)

    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われていることを確認するアサーションです。

    ``template_name`` は ``'admin/index.html'`` のような文字列です。

.. method:: assertTemplateNotUsed(response, template_name)

    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われて *いない* ことを確認するアサーションです。

    ``template_name`` は ``'admin/index.html'`` のような文字列です。


.. _E-mail services:

メールサービス
--------------

.. versionadded:: 1.0

ビューが :ref:`Django のメールサービス <topics-email>` を使っている場合、
ビューをテストするたびにメールが送信されてほしくはないでしょう。 Django の
テストランナは、テスト中に Django から送信されたすべてのメールをダミーの送
信箱に振り分けます。これによって、送信したメールの数から、各メールのメッセー
ジに至るまで、メール送信機能のすべてを (実際にメールを送らずに) テストでき
ます。

Django は、テストフレームワークを初期化する際、通常の 
:class:`~django.core.mail.SMTPConnection` クラスをダミーの SMTPConnection
実装に切替えます (Django の外部のメール送信機構、例えば Django を動かしてい
るホストで動いているメールサーバには一切影響を及ぼしません)。

.. currentmodule:: django.core.mail

.. data:: django.core.mail.output

テストの実行中、 Django から送信されたメールは ``djnago.core.mail.outbox``
に保存されます。 ``djnago.core.mail.outbox`` はその時点で送信された全ての
:class:`<~django.core.mail.EmailMessage>` インスタンスからなるリストで、テ
スト時以外には存在しません。このダミー送信箱は、テストのセットアップ時に、
ダミーの :class:`~django.core.mail.SMTPConnection` と組で初期化されます。テ
ストが終了すると、通常の :class:`~django.core.mail.SMTPConnection` が復帰し、
ダミー送信箱は削除されます。

``django.core.mail.outbox`` を調べて、メール送信数やメールの内容をチェック
するコード例を以下に示します::

    from django.core import mail
    from django.test import TestCase

    class EmailTest(TestCase):
        def test_send_email(self):
            # Send message.
            mail.send_mail('Subject here', 'Here is the message.',
                'from@example.com', ['to@example.com'],
                fail_silently=False)

            # Test that one message has been sent.
            self.assertEqual(len(mail.outbox), 1)

            # Verify that the subject of the first message is correct.
            self.assertEqual(mail.outbox[0].subject, 'Subject here')


:ref:`前節で <emptying-test-outbox>` 述べたように、テスト用の送信箱の内容は
TestCase 内の各テストケースの開始時点で抹消されます。手動で送信箱の内容を空
にしたければ、空のリストを ``mail.outbox`` に代入してください::

    from django.core import mail

    # Empty the test outbox
    mail.outbox = []

.. _Using a different testing framework:

他のテストフレームワークを使う
==============================

``doctest`` と ``unittest`` だけが Python のテストフレームワークではありま
せん。Django は他のテストフレームワークを明にサポートしているわけではありま
せんが、他のテストフレームワークで作成したテストを Django の通常のテストと
同じように呼び出すためのメカニズムは提供しています。

``./manage.py test`` を実行すると、 Django は :setting:`TEST_RUNNER` 設定を
探して、実行すべきテストランナを決定します。デフォルトでは、
:setting:`TEST_RUNNER` は ``django.test.simple.run_tests`` です。このメソッ
ドは Django のデフォルトのテスト動作を実装しており、以下のように動作します:

  #. テスト前の全体的な準備を行います。

  #. テストデータベースを生成します。

  #. ``syncdb`` を実行して、モデルと初期データをデータベースにインストールし
     ます。

  #. インストールされている全てのアプリケーションの ``models.py`` や
     ``tests.py`` から、単体テストと doctest を探します。

  #. 見つかった単体テストと doctest を実行します。

  #. テストデータベースを破壊します。

  #. テスト後の全体的な後始末を行います。

テストランナメソッドを自作して、そのメソッド名を :setting:`TEST_RUNNER` に
指定しておき、 ``./manage.py test`` を実行すると、 Django はそのテストラン
ナメソッドを実行します。これによって、 Python コードから任意のテストフレー
ムワークを実行できます。

.. _Defining a test runner:

テストランナを定義する
----------------------

.. versionadded:: 1.0

.. currentmodule:: django.test.simple

慣習的に、テストランナは ``run_tests`` と名付けます。テストランナは以下のよ
うに Django テストランナと同じ引数をとらねばなりません:

.. function:: run_tests(test_labels, verbosity=1, interactive=True, extra_tests=[])

    ``test_labels`` には、実行したいテストを表す文字列 (ラベル) のリストを
    指定します。ラベルは以下の 3 つの形式で指定できます:

        * ``app.TestCase.test_method`` - テストケース中の個別のテストメソッ
          ドを実行します。
        * ``app.TestCase`` - テストケース中の全てのテストメソッドを実行しま
          す。
        * ``app`` - アプリケーション中の全てのテストを探して実行します。

    ``test_labels`` が ``None`` の場合、テストランナは
    :setting:`INSTALLED_APPS` に登録されている全てのアプリケーションからテ
    ストを探して実行します。

    ``verbosity`` には、コンソールに出力される通知情報やデバッグ情報の量を
    指定します。  ``0`` にすると何も出力しません。 ``1`` は通常の出力、
    ``2`` は多めの出力です。

    ``interactive`` を ``True`` にすると、テストスイートの実行時に、テスト
    スイートからユーザに質問できるようになります。例えば、テストデータベー
    スを削除してよいか尋ねるといった使い方です。 ``interactive`` を
    ``False`` にする場合、テストスイートは手動操作なしで実行できねばなりま
    せん。
  
  ``extra_tests`` には、このテストランナに追加で実行させたい ``TestCase``
  インスタンスを指定します。 ``extra_tests`` を指定すると、 ``module_list``
  から発見したテストに加えて、指定したテストを実行します。
    
  このメソッドは失敗したテストの数を返さねばなりません。


.. _Testing utilities:

テスト用のユーティリティ
------------------------

.. module:: django.test.utils
   :synopsis: カスタムのテストランナを作成するためのヘルパです。

``django.test.utils`` モジュールには、テストランナの自作に役立つユーティリ
ティメソッドが定義されています。

.. function:: setup_test_environment()

    テンプレートレンダリングシステム構成のインストールなど、テスト前の全
    体的な準備を行い、ダミーの ``SMTPConnecton`` をセットアップします。

.. function:: teardown_test_environment()

    テンプレートレンダリングシステムに組み込まれた黒魔術的なフックの除去な
    ど、テスト後の全体的な後始末を行い、メールサービスを通常の状態に復帰し
    ます。

.. TBD

The creation module of the database backend (``connection.creation``) also
provides some utilities that can be useful during testing.

.. function:: create_test_db(verbosity=1, autoclobber=False)

    新たなテストデータベースを生成し、 ``syncdb`` を実行します。

    ``verbosity`` は ``run_tests()`` の同名の引数と同じ意味です。

    ``autoclobber`` には、テストデータベースと同名のデータベースが見つかっ
    た際の挙動を指定します:

        * ``autoclobber`` が ``False`` なら、既存のデータベースを破壊しても
          よいかユーザに尋ねます。ユーザが「いいえ」を選択すると、その時点
          で ``sys.exit`` を呼び出して終了します。

        * ``autoclobber`` が ``True`` なら、既存のデータベースを破壊すると
          きにユーザに了解を求めません。

    生成されたテストデータベースの名前を返します。

    ``create_test_db()`` には ``settings.DATABASE_NAME`` を変更してテストデー
    タベースの名前にするという副作用があります。

    .. versionchanged:: 1.0
       ``create_test_db()`` 生成されたテストデータベースの名前を返すように
       なりました。

.. function:: destroy_test_db(old_database_name, verbosity=1)

    このメソッドを呼び出した時点で :setting:`DATABASE_NAME` に設定されてい
    るデータベースを破壊し、 :setting:`DATABASE_NAME` の値を
    ``old_database_name`` に指定したデータベース名に戻します。

    ``verbosity`` は ``run_tests()`` の同名の引数と同じ意味です。


